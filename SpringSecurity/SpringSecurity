https://qburst.udemy.com/course/spring-security-zero-to-master/learn/lecture/22516340#overview
Refer to the pdf saved in the same folder as this file.

User details in memory instead of reading application.properties file.
User implements UserDetailsInterface
UserDetailsService extends UserDetailsInterface
UserDetailsManager extends UserDetailsService
InMemoryUserDetailsManager, JdbcUserDetailsManager and LdapUserDetailsManager are implementations of UserDetailsManager interface.
For testing purposes we can use InMemoryUserDetailsManager where user credentials are stored in apllication memory.
For production ready applications, JdbcUserDetailsManager could be used.

Default spring sec process:
User enters username and password -> Security gets the user details with the user name using loadUsersByUsername method. The password entered by the user and stored in the db are matched. If they are the same, then login succesful else fails.
Encoding - Base64
Encyption - Symmetrical(public key) and asymmetrical(private key)
Hashing - algorithms, mod
PasswordEncoder Interface -> encode, matches, upgradeEncoding methods
Different implementations of PasswordEncoders provided by Spring Security :
NoOpPasswordEncoder
StandardPasswordEncoder
Pbkdf2PasswordEncoder
BCryptPasswordEncoder
SCryptPasswordEncoder
ProviderManager implements AuthenticationManager interface. 
Spring security framework creates the authentication object after filtering and then calls the AuthenticationManager interface. In the authenticate method of ProviderManager which is the implementation of AuthenticationManager, the authenticationproviders are obtained. Using the supports method of each provider (by default, DaoAuthenticationProvider which extends AbstractUserDetailsAuthenticationProvider), it is checked if the authentication object is of the type handled by any of the providers. If so, the authenticate method of the corresponding provider is called. Inside the authenticate method (in AbstractUserDetailsAuthenticationProvider), the user entered credentials are validated. After that the authntication object is updated based on the user details obtained and isAuthentication is set to true or false.
Custom implementation of AuthenticationProvider to avoid the usage of UserDetailsService provided by Spring. We can authenticate the credentials based on our own logic by the custom AuthenticationProvider.
CORS - Cross Origin Resource sharing.
Other origins means that the URL being accessed differs from the location that the JavaScript is running from, by having:
-> A different scheme (HTTP/HTPS)
-> A different domain
-> A different port
For example a if a UI app running on one domain makes a call to an API running on a different domain, the browser block that call by default due to CORS. In monolithic applications this blocking makes sense but in microservices communication btween different domains will be needed.
CSRF - Cross-Site Request Forgery
A typical Cross-Site Request Forgery (CSRF or XSRF) attack aims to perform an operation in a web application on
behalf of a user without their explicit consent. In general, it doesn't directly steal the user's identity, but it exploits
the user to carry out an actionwithout their will.
User logged in to an application like netflix.com. Now the user has a valid active session/cookie. User clicked a malicious link builr by a hacker in his blog. Browser will append the cookie and send to the server. The server treats it as a genuine request and resets the victim's password to the value supplies by the attcker.
A CCRF token is a string that is tied to the user's session but is not submitted automatically. A website proceeds only when it receives a valid CSRF token along with the cookies, since there is no way for an attacker to know a user specific token, the attacker can not perform actions on userâ€™s behalf.
CSRF token should not be transmitted within cookies.
Authentication and Autherization
Spring security autherization based on authority and roles.
Matchers - MVC, ant and regex
Filters in Spring security - handle input validation, auditing, logging, tracing
    logging.level.org.springframework.security.web.FilterChainProxy=DEBUG
    @EnableWebSecurity(debug = true)
By adding the above configurations, we can view the list of filters in console.
Add filter before
Add filter after
Add filter At
Cookies and sessions
    Cookie history
    Cookoe-based authentication:
    The content of a cookie is secret and other websites can't read it.
    SessionId in a cookie stored in computer's file system.
    Logout -> login session will be invalidated in db and the server will instruct the browser to delete the cookie containing session id.
    If we are inactive for sometime, session will expire.
        FB -> long lived session
        bank -> short lived session(less than 5 mins)
    Cookie is only the medium to transmit session id(like fortune cookie)
    Browsers will automatically send any cookies associated with a website. Cookies are send in HTTP headers.
    Session id - randomly enerated number.
Cookies based authentication is becoming outdated atleast for some use cases.
Tokens:
Suppose we are using a mobile app that tracks expenses. We login to this app wich redirects to our bank website. Here we authenticate and the bank server sends a toke to the app. Tokens are like temporary passwords. plus they have limited access to the data. For example the app can now view transactions using the token but not do money transfers. Similar to this is granting access to Google/Fb user profile to a 3rd party website.
Popular protocols:
OAuth
OpenID
JWT - JSON web token
    Not just a temporary password.
    Contains important info like the customer id, name, scope (like view transationc), created and expire times.
    This info is cryptographically signed by the bank server. So tampering with the signature is impossible unless you are the bank.

cookies                                             tokens
---------                                           ---------
Only 2 parties involved -                           Multiple parties maybe involved - You, the bank    You and the bank                                    and the app.
Implemented as needed by the server                 Follow a standard - interoperability
                                                    tend not to need a session on the server at all.
                                                    eg:JWT contains all the session info.
                                                    Limited lifetime.
Grants access to all the information available.     Grants access to only a subset of data.
Send by Cookie HTTP header.                         Send by authorization HTTP header. (reason being many interactions now happening outside browser)
Session based approach - website                    Used for app for the same service

By default JSessionID send as cookies by Spring security. Also in our application we have the CSRF token in cookie.
JWT

Skipped tutorials : 
